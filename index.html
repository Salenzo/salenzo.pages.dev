<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<link href="favicon.svg" rel="shortcut icon">
<title>Ŝalenzo</title>
<style>
	html,
	body,
	canvas {
		display: block;
		margin: 0;
		width: 100%;
		height: 100%;
	}
</style>
<canvas id="canvas"></canvas>
<script id="vs" type="text/x-glsl">
#version 300 es

in vec4 a_position;
in vec2 a_texcoord;
out vec2 v_texcoord;

void main() {
	v_texcoord = a_texcoord;
	gl_Position = a_position;
}
</script>
<script id="fs0" type="text/x-glsl">
#version 300 es
precision mediump float;

in vec2 v_texcoord;
out vec4 outColor;
uniform sampler2D textBuffer;
uniform sampler2D font;
uniform sampler2D palette;

void main() {
	vec4 cell = texture(textBuffer, v_texcoord) * .99609375; // 255/256
	outColor = mix(
		texture(palette, vec2(cell.a)),
		texture(palette, vec2(cell.a * 16.)),
		texture(font, cell.rg + fract(v_texcoord * vec2(textureSize(textBuffer, 0))) / 32.)
	);
}
</script>
<script id="fs1" type="text/x-glsl">
#version 300 es
// https://github.com/Swordfish90/cool-retro-term/blob/1.2.0/app/qml/ShaderTerminal.qml
precision mediump float;

in vec2 v_texcoord;
out vec4 outColor;
uniform highp float time;
uniform highp float glowingLine;
uniform highp float staticNoise;
uniform lowp float rgbShift;
uniform lowp float chromaColor;
uniform lowp float bloom;
uniform lowp float jitter;
uniform lowp float flickering;
uniform lowp float screenCurvature;
uniform lowp float screenShadowCoeff;
uniform lowp float frameShadowCoeff;
uniform lowp vec4 frameColor;
uniform lowp vec4 fontColor;
uniform lowp vec4 backgroundColor;
uniform mediump vec2 margin;
uniform sampler2D vram;

float rgb2grey(vec3 v) {
	return dot(v, vec3(.2126, .7152, .0722));
}

vec3 convertWithChroma(vec3 v) {
	return fontColor.rgb * mix(vec3(rgb2grey(v)), v, chromaColor);
}

vec4 blur4(sampler2D image, vec2 uv) {
	// https://code.qt.io/cgit/qt/qt5compat.git/tree/src/imports/graphicaleffects5/shaders_ng/fastblur_internal.vert?h=6.9.1
	// https://code.qt.io/cgit/qt/qt5compat.git/tree/src/imports/graphicaleffects5/shaders_ng/fastblur_internal.frag?h=6.9.1
	vec2 step = vec2(.002, .002);
	return .25 * (texture(image, vec2(uv.x + step.x, uv.y + step.y * 0.36))
		+ texture(image, vec2(uv.x + step.x * 0.36, uv.y - step.y))
		+ texture(image, vec2(uv.x - step.x * 0.36, uv.y + step.y))
		+ texture(image, vec2(uv.x - step.x, uv.y - step.y * 0.36)));
}

float max2(vec2 v) {
	return max(v.x, v.y);
}

float sum2(vec2 v) {
	return v.x + v.y;
}

float prod2(vec2 v) {
	return v.x * v.y;
}

vec2 positiveLog(vec2 x) {
	return clamp(log(x), vec2(0.0), vec2(100.0));
}

vec3 hash33(vec3 p3) {
	// https://www.shadertoy.com/view/4djSRW
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yxz + 33.33);
	return fract((p3.xxy + p3.yxx) * p3.zyx);
}

void main() {
	vec3 noiseVal = hash33(vec3(gl_FragCoord.xy, fract(time * .0114514)));

	vec2 cc = v_texcoord - vec2(0.5);
	float distance = dot(cc, cc) * screenCurvature;
	vec2 curvatureCoords = v_texcoord + cc * (1.0 + distance) * distance;
	curvatureCoords *= vec2(1.0) + margin * 2.0;
	curvatureCoords -= margin;
	vec2 txt_coords = -2.0 * curvatureCoords + 3.0 * step(vec2(0.0), curvatureCoords) * curvatureCoords - 3.0 * step(vec2(1.0), curvatureCoords) * (curvatureCoords - 1.0);
	txt_coords += (noiseVal.xy - vec2(0.5)) * vec2(.0035, .001) * jitter;
	vec3 txt_color = texture(vram, txt_coords).rgb;

	vec2 displacement = vec2(12.0, 0.0) * rgbShift;
	vec3 rightColor = texture(vram, txt_coords + displacement).rgb;
	vec3 leftColor = texture(vram, txt_coords - displacement).rgb;
	txt_color *= .6;
	txt_color += leftColor * vec3(.1, .2, .3) + rightColor * vec3(.3, .2, .1);

	{
		float color = 0.0001;
		float noise = staticNoise;
		color += noiseVal.z * noise * (1.0 - distance * 1.3);
		color += fract(smoothstep(-120.0, 0.0, curvatureCoords.y * 114.514 - (114.514 + 120.0) * fract(time * .0001))) * glowingLine;
		txt_color += vec3(0.0001);
		txt_color += fontColor.rgb * vec3(color);
	}
	float greyscale_color = rgb2grey(txt_color);

	float reflectionMask = sum2(step(vec2(0.0), curvatureCoords) - step(vec2(1.0), curvatureCoords));
	reflectionMask = clamp(reflectionMask, 0.0, 1.0);

	vec3 foregroundColor = mix(fontColor.rgb, txt_color * fontColor.rgb / greyscale_color, chromaColor);
	vec3 finalColor = mix(backgroundColor.rgb, foregroundColor, greyscale_color * reflectionMask);

	vec4 bloomFullColor = blur4(vram, txt_coords);
	vec3 bloomColor = bloomFullColor.rgb;
	float bloomAlpha = bloomFullColor.a;
	bloomColor = convertWithChroma(bloomColor);
	finalColor += clamp(bloomColor * bloom * bloomAlpha, 0.0, 0.5);
	finalColor *= 1.0 + clamp(sin(time * .00114) + cos(time * .00514) + (fract(time * .01919) - .5) * fract(time * .00810) * .25, -.5, .5) * flickering;

	vec2 vignetteCoords = v_texcoord * (1.0 - v_texcoord.yx);
	float vignette = pow(prod2(vignetteCoords) * 15.0, 0.25);
	vec3 color = frameColor.rgb * vec3(1.0 - vignette);
	float frameShadow = max2(positiveLog(-curvatureCoords * frameShadowCoeff + vec2(1.0)) + positiveLog(curvatureCoords * frameShadowCoeff - vec2(frameShadowCoeff - 1.0)));
	frameShadow = max(sqrt(frameShadow), 0.0);
	color *= frameShadow;
	float alpha = sum2(1.0 - step(vec2(0.0), curvatureCoords) + step(vec2(1.0), curvatureCoords));
	alpha = clamp(alpha, 0.0, 1.0);
	alpha *= mix(1.0, .9, frameShadow);
	{
		float screenShadow = 1.0 - prod2(positiveLog(curvatureCoords * screenShadowCoeff + vec2(1.0)) * positiveLog(-curvatureCoords * screenShadowCoeff + vec2(screenShadowCoeff + 1.0)));
		alpha = max(.8 * screenShadow, alpha);
	}

	outColor = vec4(mix(finalColor, color, alpha), 1.0);
}
</script>
<script src="/vendor/twgl.min.js"></script>
<script>
	const gl = canvas.getContext('webgl2', { alpha: false, powerPreference: 'low-power' })

	const lerp = (a, b, t) => a * (1 - t) + b * t
	const mix = (c1, c2, alpha) => c1.map((x, i) => lerp(c2[i], x, alpha))
	let backgroundColor = [0, 0, 0, 1]
	let fontColor = [1, 1, 1, 1]
	let glowingLine = .15
	let ambientLight = .15
	let screenCurvature = .4
	let cols = 80
	let bloom = .3

	const bufferInfo0 = twgl.createFramebufferInfo(gl, [
		{ mag: gl.NEAREST },
	], 8 * 80, 16 * 24)

	const drawObjects0 = [{
		programInfo: twgl.createProgramInfo(gl, ['vs', 'fs0']),
		bufferInfo: twgl.createBufferInfoFromArrays(gl, {
			a_position: [-1, 3, 0, 3, -1, 0, -1, -1, 0],
			a_texcoord: [0, 2, 2, 0, 0, 0],
		}),
		uniforms: twgl.createTextures(gl, {
			// Textures are for text, sure…
			textBuffer: { src: [0, 0, 0, 0], minMag: gl.NEAREST },
			font: { src: 'font.webp', mag: gl.NEAREST, color: [0, 0, 0, 0] },
			palette: {
				width: 16,
				height: 1,
				src: [
					0x00, 0x00, 0x00, 0xff,
					0x00, 0x00, 0xaa, 0xff,
					0x00, 0xaa, 0x00, 0xff,
					0x00, 0xaa, 0xaa, 0xff,
					0xaa, 0x00, 0x00, 0xff,
					0xaa, 0x00, 0xaa, 0xff,
					0xaa, 0x55, 0x00, 0xff,
					0xaa, 0xaa, 0xaa, 0xff,
					0x55, 0x55, 0x55, 0xff,
					0x55, 0x55, 0xff, 0xff,
					0x55, 0xff, 0x55, 0xff,
					0x55, 0xff, 0xff, 0xff,
					0xff, 0x55, 0x55, 0xff,
					0xff, 0x55, 0xff, 0xff,
					0xff, 0xff, 0x55, 0xff,
					0xff, 0xff, 0xff, 0xff,
				],
				minMag: gl.NEAREST,
			},
		}),
	}]

	const drawObjects1 = [{
		programInfo: twgl.createProgramInfo(gl, ['vs', 'fs1']),
		bufferInfo: twgl.createBufferInfoFromArrays(gl, {
			a_position: [-1, 3, 0, 3, -1, 0, -1, -1, 0],
			a_texcoord: [0, -1, 2, 1, 0, 1],
		}),
		uniforms: {
			time: 0,
			glowingLine,
			staticNoise: .05,
			rgbShift: .015 / cols,
			chromaColor: 1,
			bloom: bloom * 2.5,
			jitter: .15,
			flickering: .1,
			screenCurvature: screenCurvature * .4,
			screenShadowCoeff: lerp(18, 12, ambientLight),
			frameShadowCoeff: lerp(18, 12, ambientLight),
			frameColor: mix([1, 1, 1, 1], mix(fontColor, backgroundColor, .2), lerp(.2, .8, ambientLight)),
			fontColor,
			backgroundColor,
			margin: [.05, .05],
			vram: bufferInfo0.attachments[0],
		},
	}]

	const textBuffer = new Uint8Array(80 * 24 * 4)
	let textBufferDirty = false
	let cursorX = 0
	let cursorY = 0
	function print(text, x = cursorX, y = cursorY, color = 0x07) {
		let p = (y * 80 + x) * 4
		for (let i = 0; i < text.length; i++) {
			const charCode = text.charCodeAt(i)
			if (charCode === 0x0a) {
				p = (Math.floor(p / (80 * 4)) + 1) * (80 * 4)
			} else {
				textBuffer[p++] = (charCode & 0x1f) << 3
				textBuffer[p++] = (charCode & 0x3e0) >> 2
				textBuffer[p++] = 0
				textBuffer[p++] = color
			}
			if (p > textBuffer.length) {
				textBuffer.copyWithin(0, 80 * 4)
				textBuffer.fill(0, -80 * 4)
				p = textBuffer.length - 80 * 4
			}
		}
		textBufferDirty = true
		cursorX = p / 4 % 80
		cursorY = Math.floor(p / 4 / 80)
	}
	print('Ŝalenzo BIOS\nCopyright (C) 2025 Ŝalenzo\n')
	setInterval(() => {
		print((Math.random() * 16 | 0).toString(16).toUpperCase())
	}, 100)

	requestAnimationFrame(function render(time) {
		twgl.resizeCanvasToDisplaySize(gl.canvas)

		if (textBufferDirty) {
			twgl.setTextureFromArray(gl, drawObjects0[0].uniforms.textBuffer, textBuffer, {
				width: 80,
				height: 24,
				minMag: gl.NEAREST,
			})
			textBufferDirty = false
		}
		twgl.bindFramebufferInfo(gl, bufferInfo0)
		gl.clearColor(.19, .19, .810, 1)
		gl.clear(gl.COLOR_BUFFER_BIT)
		twgl.drawObjectList(gl, drawObjects0)

		gl.bindFramebuffer(gl.FRAMEBUFFER, null)
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
		gl.clearColor(.114, .514, .1919, 1)
		gl.clear(gl.COLOR_BUFFER_BIT)
		drawObjects1[0].uniforms.time = time
		twgl.drawObjectList(gl, drawObjects1)

		requestAnimationFrame(render)
	})
</script>
